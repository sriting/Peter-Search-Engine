14203
www.ics.uci.edu/~dock/manuals/python/SCORE.html
Python: module SCORE SCORE index /home/dock/programs/MOL2/SCORE.py Modules re sys Classes __builtin__.dict(__builtin__.object) score scorelist __builtin__.list(__builtin__.object) headerclass scorelist_iter class headerclass(__builtin__.list) Method resolution order: headerclass __builtin__.list __builtin__.object Methods defined here: __init__(self, line='') __str__(self) abut(self, other) Data and other attributes defined here: __dict__ = <dictproxy object> dictionary for instance variables (if defined) __weakref__ = <attribute '__weakref__' of 'headerclass' objects> list of weak references to the object (if defined) Methods inherited from __builtin__.list: __add__(...) x.__add__(y) <==> x+y __contains__(...) x.__contains__(y) <==> y in x __delitem__(...) x.__delitem__(y) <==> del x[y] __delslice__(...) x.__delslice__(i, j) <==> del x[i:j] Use of negative indices is not supported. __eq__(...) x.__eq__(y) <==> x==y __ge__(...) x.__ge__(y) <==> x>=y __getattribute__(...) x.__getattribute__('name') <==> x.name __getitem__(...) x.__getitem__(y) <==> x[y] __getslice__(...) x.__getslice__(i, j) <==> x[i:j] Use of negative indices is not supported. __gt__(...) x.__gt__(y) <==> x>y __hash__(...) x.__hash__() <==> hash(x) __iadd__(...) x.__iadd__(y) <==> x+=y __imul__(...) x.__imul__(y) <==> x*=y __iter__(...) x.__iter__() <==> iter(x) __le__(...) x.__le__(y) <==> x<=y __len__(...) x.__len__() <==> len(x) __lt__(...) x.__lt__(y) <==> x<y __mul__(...) x.__mul__(n) <==> x*n __ne__(...) x.__ne__(y) <==> x!=y __repr__(...) x.__repr__() <==> repr(x) __rmul__(...) x.__rmul__(n) <==> n*x __setitem__(...) x.__setitem__(i, y) <==> x[i]=y __setslice__(...) x.__setslice__(i, j, y) <==> x[i:j]=y Use of negative indices is not supported. append(...) L.append(object) -- append object to end count(...) L.count(value) -> integer -- return number of occurrences of value extend(...) L.extend(iterable) -- extend list by appending elements from the iterable index(...) L.index(value, [start, [stop]]) -> integer -- return first index of value insert(...) L.insert(index, object) -- insert object before index pop(...) L.pop([index]) -> item -- remove and return item at index (default last) remove(...) L.remove(value) -- remove first occurrence of value reverse(...) L.reverse() -- reverse *IN PLACE* sort(...) L.sort(cmpfunc=None) -- stable sort *IN PLACE*; cmpfunc(x, y) -> -1, 0, 1 Data and other attributes inherited from __builtin__.list: __new__ = <built-in method __new__ of type object> T.__new__(S, ...) -> a new object with type S, a subtype of T class score(__builtin__.dict) Method resolution order: score __builtin__.dict __builtin__.object Methods defined here: __init__(self, header=None, data=[]) __str__(self, printunknown=True) abut(self, other) hasUnknown(self) key(self) Data and other attributes defined here: __dict__ = <dictproxy object> dictionary for instance variables (if defined) __weakref__ = <attribute '__weakref__' of 'score' objects> list of weak references to the object (if defined) Methods inherited from __builtin__.dict: __cmp__(...) x.__cmp__(y) <==> cmp(x,y) __contains__(...) x.__contains__(y) <==> y in x __delitem__(...) x.__delitem__(y) <==> del x[y] __eq__(...) x.__eq__(y) <==> x==y __ge__(...) x.__ge__(y) <==> x>=y __getattribute__(...) x.__getattribute__('name') <==> x.name __getitem__(...) x.__getitem__(y) <==> x[y] __gt__(...) x.__gt__(y) <==> x>y __hash__(...) x.__hash__() <==> hash(x) __iter__(...) x.__iter__() <==> iter(x) __le__(...) x.__le__(y) <==> x<=y __len__(...) x.__len__() <==> len(x) __lt__(...) x.__lt__(y) <==> x<y __ne__(...) x.__ne__(y) <==> x!=y __repr__(...) x.__repr__() <==> repr(x) __setitem__(...) x.__setitem__(i, y) <==> x[i]=y clear(...) D.clear() -> None. Remove all items from D. copy(...) D.copy() -> a shallow copy of D get(...) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. has_key(...) D.has_key(k) -> True if D has a key k, else False items(...) D.items() -> list of D's (key, value) pairs, as 2-tuples iteritems(...) D.iteritems() -> an iterator over the (key, value) items of D iterkeys(...) D.iterkeys() -> an iterator over the keys of D itervalues(...) D.itervalues() -> an iterator over the values of D keys(...) D.keys() -> list of D's keys pop(...) D.pop(k[,d]) -> v, remove specified key and return the corresponding value If key is not found, d is returned if given, otherwise KeyError is raised popitem(...) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty setdefault(...) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update(...) D.update(E) -> None. Update D from E: for k in E.keys(): D[k] = E[k] values(...) D.values() -> list of D's values Data and other attributes inherited from __builtin__.dict: __new__ = <built-in method __new__ of type object> T.__new__(S, ...) -> a new object with type S, a subtype of T fromkeys = <built-in method fromkeys of type object> dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v. v defaults to None. class scorelist(__builtin__.dict) Method resolution order: scorelist __builtin__.dict __builtin__.object Methods defined here: __init__(self) __iter__(self) __len__(self) abut(self, other, keepunknowns=False) Equivalent to an SQL join, this function abuts two scorelists using columns specified by scorelist.header.key add_column(self, name, col, description='') append(self, score) append_list(self, other) Appends an interable of scores to this scorelist. Does not add columns to the header. This must be done diretly through the header class. delete_column(self, name) ensure_column(self, key) get_column(self, name) Gets a column of data. Use this rather than scorelist['columnname']. get_score(self, n) Get's a score from the list by it's index. idx_of(self, searchfor='KNOWN') Return a list of tuples (index, match_object), containing comments that match the 'searchfor' regular expression. Match objects returnd can be use to extract row specific information from each index. E.g. searchfor="pKi (?P<pki>.*)$" would allow you query the match objects using the group method for 'pki', parsing comments like '// pKi 5.83'. len(self) makedict(self, key='NAME') Utility function that adds a attribute 'dict' containing a mapping of names to indexes. mark_list(self, comment='') Simple function to annotate top of scorelist with comments applying to the whole list. All comment lines begin with '//' which is automatically prepended by this function. All list modifying functions should produce annotation. Comments stored in self.comment. mark_score(self, key, value, comment) Simple function to annotate specific element of scorelist with a comment pinned to it. Regular expressions are permitted. All comment lines begin with '//' comments stored in self.comments. print2file(self, file, printunknown=True) Use this to print a scorelist to a file. We don't implement __str__ because this object can be quite large and it make sense to print directly to file. read(self, file) readmol2(self, molseq, getFingerprint=False, bits=512) set_column(self, name, col) sort(self, key='NAME') Sort based on a key. Automatically tries to convert data to float unless an exception is raised. transform_column(self, name, transform_function, description=None) Applies transform_function to every element of a particular column. Data and other attributes defined here: __dict__ = <dictproxy object> dictionary for instance variables (if defined) __weakref__ = <attribute '__weakref__' of 'scorelist' objects> list of weak references to the object (if defined) Methods inherited from __builtin__.dict: __cmp__(...) x.__cmp__(y) <==> cmp(x,y) __contains__(...) x.__contains__(y) <==> y in x __delitem__(...) x.__delitem__(y) <==> del x[y] __eq__(...) x.__eq__(y) <==> x==y __ge__(...) x.__ge__(y) <==> x>=y __getattribute__(...) x.__getattribute__('name') <==> x.name __getitem__(...) x.__getitem__(y) <==> x[y] __gt__(...) x.__gt__(y) <==> x>y __hash__(...) x.__hash__() <==> hash(x) __le__(...) x.__le__(y) <==> x<=y __lt__(...) x.__lt__(y) <==> x<y __ne__(...) x.__ne__(y) <==> x!=y __repr__(...) x.__repr__() <==> repr(x) __setitem__(...) x.__setitem__(i, y) <==> x[i]=y clear(...) D.clear() -> None. Remove all items from D. copy(...) D.copy() -> a shallow copy of D get(...) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. has_key(...) D.has_key(k) -> True if D has a key k, else False items(...) D.items() -> list of D's (key, value) pairs, as 2-tuples iteritems(...) D.iteritems() -> an iterator over the (key, value) items of D iterkeys(...) D.iterkeys() -> an iterator over the keys of D itervalues(...) D.itervalues() -> an iterator over the values of D keys(...) D.keys() -> list of D's keys pop(...) D.pop(k[,d]) -> v, remove specified key and return the corresponding value If key is not found, d is returned if given, otherwise KeyError is raised popitem(...) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty setdefault(...) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update(...) D.update(E) -> None. Update D from E: for k in E.keys(): D[k] = E[k] values(...) D.values() -> list of D's values Data and other attributes inherited from __builtin__.dict: __new__ = <built-in method __new__ of type object> T.__new__(S, ...) -> a new object with type S, a subtype of T fromkeys = <built-in method fromkeys of type object> dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v. v defaults to None. class scorelist_iter Iterator implemented as a seperate class from scorelist so different position information can be held by seperate iterators. Methods defined here: __init__(self, scorelist) next(self) Functions isComment(line) isData(line) isHeader(line) mol2scorereader(mol2seq, getFingerprint=False, bits=512) scorereader(file)