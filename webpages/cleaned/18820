18820
www.ics.uci.edu/~pattis/ICS-33/assignments/program2/program.html
Program 2 Program 2 Classes and Overloaded Operators (and one Iterator) ICS-33: Intermediate Programming Introduction This programming assignment is designed first to ensure that you know how to write classes that overload many of the standard Python operators by defining various double-underscore methods. It also ensures that you know how to write classes that implement iterators, by defining an __iter__ method that returns an object that we/Python can call __next__ on. These Iterators are covered near the end of the due date for this project; skip writing these functions (only in the first class) until the material is covered in class, or read ahead. You should download the program2 project folder and unzip it to produce an Eclipse project with two modules. You will write classes in these modules, which can be tested in the script and using the standard driver using the batch self-check files that I supplied. Eventually you will submit each of these modules you write separately to Checkmate. I recommend that you work on this assignment in pairs, and I recommend that you work with someone in your lab section (so that you have 4 hours each week of scheduled time together). These are just recommendations. Try to find someone who lives near you, with similar programming skills, and work habits/schedule: e.g., talk about whether you prefer to work mornings, nights, or weekends; what kind of commitment you will make to submit program early. Only one student should submit all parts of the the assignment, but both students' UCInetID and name should appear in a comment at the top of each submitted .py file. A special grading program reads this information. The format is a comment starting with Submitter and Partner (when working with a partner), followed by a colon, followed by the student's UCInetID (in all lower-case), followed by the student's name in parentheses (last name, comma, first name -capitalized appropriately). If you omit this information, or do not follow this exact form, it will require extra work for us to grade your program, so we will deduct points. Note: if you are submitting by yourself, and do NOT have a partner, you should OMIT the partner line and the "...certify" sentence. For example if Romeo Montague (whose UCInetID is romeo1) submitted a program that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet) the comment at the top of each .py file would appear as: # Submitter: romeo1(Montague, Romeo)
# Partner  : jcapulet(Capulet, Juliet)
# We certify that we worked cooperatively on this programming
#   assignment, according to the rules for pair programming If you do not know what the terms cooperatively and/or rules for pair programming mean, please read about Pair Programming before starting this assignment. Please turn in each program as you finish it, so that I can more accurately assess the progress of the class as a whole during this assignment. Print this document and carefully read it, marking any parts that contain important detailed information that you find (for review before you turn in the files). The code you write should be as compact and elegant as possible, using appropriate Python idioms. Problem #1: Bag Class Problem Summary: Write a class that represents and defines methods, operators, and an iterator for the Bag class. Bags are similar to sets, and have similar operations (of which we will implement just the most important) but unlike sets they can store multiple copies of items. We will store the information in bags as dictionaries (I suggest using a defaultdict) whose keys are associated with int values that specify the number of times the key occurs in the Bag. You must store Bags using this one data structure, as specified Details Define a class named Bag in a module named bag.py Define an __init__ method that has one parameter, an iterable of values that initalize the bag. Writing Bag() constructs an empty bag. Writing Bag(['d','a','b','d','c','b','d']) construct a bag with one 'a', two 'b's, one 'c', and three 'd's. Objects in the Bag class should store only the dictionary specified above: it should not store/manipulate any other self variables. Define a __repr__ method that returns a string, which when passed to eval returns a newly constructed bag with the same value (==) to the object __repr__ was called on. For example, for the Bag in the discussion of __init__ the __repr__ method would print its result as Bag(['a', 'c', 'b', 'b', 'd', 'd', 'd']). Bags like sets are not sorted, so these 7 values can appear in any order. We might require that information in the list is sorted, but not all values we might put in a bag may be ordered (and therefore not sortable): e.g., a bag storing both string and int values, Bag(['a',1]) which is allowed. Note: This method is used to test several other methods/operators in the batch self-check file; so it is critical to write it correctly. Define a __str__ method that returns a string that more compactly shows a bag. For example, for the Bag in the discussion of __init__ the __str__ method would print its result as Bag(a[1], c[1], b[2], d[3]). Bags like sets are not sorted, so these 7 values can appear in any order. Define a __len__ method that returns the total number of values in the Bag. For example, for the Bag in the discussion of __init__ the __len__ method would return 7. Define a unique method that returns the number of different (unique) values in the Bag. For example, for the Bag in the discussion of __init__ the unique method would return 4, because there are four different values in the Bag; contrast this method with __len__. Define a __contains__ method that returns whether or not its argument is in the Bag (one or more times). Define a count method that returns the number of times its argument is in the Bag: 0 if the argument is not in the Bag. Define an add method that adds its argument to the Bag: if that value is already in the Bag, its count is incremented by 1; if it is not already in the Bag, it is added to the Bag with a count of 1. Define an __add__ method that unions its two Bag operands: it returns a new Bag with all the values in Bag operands. For example: str(Bag(['a','b']) + Bag(['b','c'])) should be 'Bag(a[1],b[2],c[1])' Neither Bag operand should change. Define a remove method that removes its argument from the Bag: if that value is already in the Bag, its count is decremented by 1 (and if the count reduces to 0, the value is removed from the dictionary; if it is not in the Bag, raise a ValueError exception, with an appropriate message that includes the value that could not be removed. Define __eq__/__ne__ methods that return whether one Bag is equal/not equal to another: contains the same values the same number of times. A Bag is not equal to anything whose type is not a Bag This this method should not change either Bag. Define an __iter__ method that that returns an object on which next can be called to produce every value in the Bag: all len of them. For example, for the Bag in the discussion of __init__, the following code   for i in x:
      print(i,end='') would print   acbbddd Bags like sets are not sorted, so these 7 values can appear in any order. Ensure that the iterator produces those values in the Bag at the time the iterator starts executing; so mutating the Bag afterwards, or even during the iteration, will not affect what values it produces. Hint: Write this method as a call to a local generator, passing a copy of the dictionary (covered in Friday's lecture in Week 4). I have shown only examples of Bags storing strings, because they are convenient to write. But bags can store any type of data. The __repr__, __str__, and __iter__/__next__ methods must be written independently: neither should call the other to get things done. Testing The bag.py module includes a script that calls driver.driver(). The project folder contains a bscp21S19.txt file (examine it) to use for batch-self-checking your class. These are rigorous but not exhaustive tests. Incrementally write and test your class; check each method as you write it. Note that when exceptions are raised, they are printed by the driver but the Command: prompt sometimes appears misplaced. You can write other code at the bottom of your bag.py module to test the Bag class, or type code into the driver as illustrated below. Notice the default for each command is the command previously entered.   Driver started
  Command[!]: from bag import Bag
  Command[from bag import Bag]: b = Bag(['d','a','b','d','c','b','d'])
  Command[b = Bag(['d','a','b','d','c','b','d'])]: print(b)
  Bag(a[1], b[2], c[1], d[3])
  Command[len(b)]: print(len(b))
  7
  Command[print(len(b))]: print(b.count('d'))
  3
  Command[print(b.count('d'))]: quit
  Driver stopped Problem #2: Rational Class (operators) Problem Summary: Write a class that represents and defines operators for Rational numbers, which are represented by an int numerator and denominator. With this class we can write scripts manipulating this new numeric type, which unlike floats performs exact numeric calculations. For example   x = 0
  for i in irange(1,10): x += 1/10
  print(x) # prints 0.9999999999999999

  x = Rational(0)
  for i in irange(1,10): x += Rational(1,10)
  print(x) # prints 1/1

  print(compute_e(100 ))                 # e ~ 1/0! + 1/1! + 1/2! + ... 1/100!
  print(compute_e(100).approximate(100)) # show 100 decimal digit approximation

  (which prints... look for the / as the 10th character on the 3rd line)
  42997789077987677528011991222420376346635182807847142751317828133465975238
  70956720660008227544949996496057758175050906671347686438130409774741771022
  426508339/1581800261761765299689817607733333906622304546853925787603270574
  49521355920728670523629599959587319129243555798012243658052856289689600000
  0000000000000000000

  2.718281828459045235360287471352662497757247093699959574966967627724076630
  3535475945713821785251664274 Details Define a class named Rational in a module named rational.py This class includes three static methods: _gcd, _validate_arithmetic, and _validate_relational. All static methods are called explicitly using the Rational class name and all have no self parameter. The _gcd method computes the greatest common divisor of two values: Rational._gcd(12,18) returns 6. The two validate methods are parameterized to allow for the easy diagnosing of type mismatches for Rational operators, raising a TypeError exception if the types don't match. See the comments prefacing these these methods. __init__ has two parameters, the numerator then denominator of the rational number being constructed (use default values of 0 and 1 respectively, so just as int() is 0, Rational() is 0/1 (this is how it will print with __str__ method described below). This method should raise AssertionError(s) if either parameter is not an int or if the denominator is 0. All exceptions should be raised in the form Class.method description, where description includes the relevant values underlying the error: e.g., Rational.__init__ numerator is not int: 1.0. Objects in the Rational class are immutable: the methods you will write should never rebind any attribute names (except __init__, which initializes them); operators should return newly constructed Rational objects. IMPORTANT: You must use the names num and denom for your two attributes, and this class should define no other attribute names. The following data invariants should be implemented in __init__ for representing rational numbers; you can use these invariants to help simplify the code in the methods you will write. Zero is always represented by 0/1. The denominator is always positive; rational numbers are negative or positive based on the sign of their numerator. The numerator and denominator are stored in the lowest possible terms: they have no factors in common (use _gcd to establish this data invariant. For example, print(Rational(6,-8)) prints -3/4 (see __str__ below): the numerator is negative and the numerator and denominator have no common factors. __str__ returns a string, with the (signed) numerator and the denominator (always positive) separated by a slash(/); see examples of of printing a Rational above. __repr__ returns a string, which when passed to eval returns a newly constructed rational with the same value (==) to the object __repr__ was called on. So, repr(Rational(1,2)) returns 'Rational(1,2)'. Write the undescore method so that Python will consider 0/1 to be False (when used by itself in an if) and non-0 Rational number to be True. Write the indexing method as follows: its argument can be the int values 0 or 1, or any non-empty string that is prefix of the str values 'numerator or 'denominator' (ignore case for indexing). For an index of 0 or non-empty and a prefix of 'numerator', return the numerator; for an index of 1 or non-empty anya prefix of 'denominator' return the denominator. So, Rational(-3,4)[0] or Rational(-3,4)['Num'] returns the numerator (-3). Raise an TypeErrorexception if it is none of these cases. Write all the underscore methods needed to ensure the prefix operators + and -, and the function abs work correctly. All these methods return Rational objects. Write all the underscore methods needed to ensure that the add, subtract, multiply, and true-divide (/) operators produce the correct answers when their operands are any combination of Rational and int values. All these methods return Rational objects. Hint: When mixing types, convert the int into an equivalent Rational and then perform the operation on two rationals: e.g., convert 5 to Rational(5,1) before performing the operation. If Python tries to apply an arithmetic operator to a Rational and any other type of value (besides Rational or int) raise the standard TypeError with the standard messsage about unsupported operand types: see what 1+'a' produces. Remember: I wrote a class method (and annotationed it as a @staticmethod) to check and raise these kinds of exceptions easily. Write the underscore method that allows us to raise a Rational to any int power (positive or negative): e.g., print(Rational(1,2)**10) prints 1/1024 and print(Rational(2,1)**-2) prints 1/4: a**(-b_ = 1/(a**b) Write all the underscore methods needed to ensure that we can compare two Rationals with the six standard relational operators, with any combination of Rational and int (as with the arithmetic operators). If Python tries to compare a Rational with any other type of value raise the standard TypeError with the standard messsage about unorderable types. Remember: I wrote a class method (and annotationed it as a @staticmethod) to check and raise these kinds of exceptions easily. Write a call method that returns a string showing the decimal approximation of the Rational to the specified number of decimal places. So, if we define x = Rational(1,123) then calling x(10) returns the string '.0081300813'. Hint: deal with the sign of the result, the integer part, and the decimal part separately (you don't have to round the last digit). For the fractional part, simulate doing long division to get the needed decimal digits. For example, when computing five digits of 39/19, think of this as 38/19 + 1/19, so the answer is 2 (with decimal computed below, starting with 1 multipled by 10 = 10).         .05263
       ----------------
  19   |  10             (1 multiplied by 10)
       | - 0             (0 x 19)
       | -----------------
       |  100            (10 multiplied by 10)
       | - 95            (5 x 19)
       | -----------------
       |    50           (5 multiplied by 10)
       |   -38           (2 x 19)
       | -----------------
       |    120          (12 multiplied by 10)
       |   -114          (6 x 19)
       | -----------------
       |      60         (6 multiplied by 10)
       |     -57         (3 x 19)
       | -----------------
       |       30        (3 multiplied by 10)... Write the __setattr__ method so that after the num and denom attribute names are set in __init__, trying to change either will raise the NameError exception with an appropriate message about which attribute name was attempted to be changed. Also, do not allow any other attributes to be added. The Rational class I am asking you to write duplicates the functionality of the Fraction class currently available in Python. You may not use the Fraction class, nor the Decimal class in any of your code. Use only the classes imported in the download (or others that don't "trivialize" the assignment). Finally, I have written the compute_e and compute_pi functions, which both are truncated infinite series that approximate these fundamental constants (and heavily exercise the correctness of your arithmetic operators). Testing The rational.py module includes a script that calls driver.driver(). The project folder contains a bscp22S19.txt file (examine it) to use for batch-self-checking your class. These are rigorous but not exhaustive tests. Incrementally write and test your class: for example, getting one arithmetic operator working correctly will create a pattern for the others. Note that when exceptions are raised, they are printed by the driver but the Command: prompt sometimes appears misplaced (out of order). You can write other code at the bottom of your rational.py module to test the Rational class, or type code into the driver as illustrated below. Notice the default for each command is the command previously entered.   Driver started
  Command[!]: from rational import Rational as Rat
  Command[from rational import Rational as Rat]: x = Rat(1,2)
  Command[x = Rat(1,3)]: y = Rat(1,3)
  Command[y = Rat(1,3)]: print(x+y)
  5/6
  Command[print(x+y)]: print(-x)
  -1/2
  Command[print(-x)]: print(x+2*y)
  7/6
  Command[print(x+2*y)]: print(x > y)
  True
  Command[print(x > y)]: from rational import compute_e
  Command[from Rational import compute_e]: print(compute_e(10))
  9864101/3628800
  Command[print(compute_e(10))]: print(x+1.)
  Traceback (most recent call last):
    File "C:\Users\Pattis\workspace\courselib\driver.py", line 229, in driver
    ...
  TypeError: unsupported operand type(s) for +: 'Rational' and 'float'
  Command[print(x+1.)]: quit
  Driver stopped